---
title: 'Vibe-кодинг 101: практические советы'
description: "<strong>1. Планируй заранее.</strong> Прежде чем писать код — обсуди идею с LLM, оформи краткий PRD в `requirements.md` и согласуй первый промпт."
image: img/blog/2025/2025-09-16-paris.jpg
categories: Разработка
date: 2025-09-16
---

> **PRD (Product Requirements Document)**. Документ с требованиями к продукту: пользовательские сценарии, функционал, ограничения, интеграции. Помогает команде работать в одном контексте, а `solopreneur`'у, типа меня, держаться выбранной цели и корректировать ее, если нужно. PRD – это не ТЗ (техническое задание). PRD описывает, что надо сделать: функциональность и бизнес-цели. А ТЗ – как это сделать, общие инженерные решения.

**2. Если разработка не no-code**, кодируй в [VS Code c Codex или Gemini CLI](/ru/blog/2025/gemini-chatgpt-vs-code-copilot) или в [Cursor'е](/ru/blog/2024/cursor). Подключи [Eslint](https://eslint.org/), [Stylelint](https://stylelint.io/) и [Prettier](https://prettier.io/). Правильное форматирование — первое средство от ошибок.

**3. Делай маленькими шагами**. Реализуй одну фичу за раз, проверяй её тест-кейсовыми промптами. Для багов — отдельные итерации.

> **Тест-кейс (test case)**. Набор условий и шагов для проверки конкретной функции приложения. Помогает убедиться, что код работает как ожидается.

**4. Выбирайся из «петель Дори»**. Не гоняй один и тот же промпт. Добавляй контекст: логи, скриншоты, описание шагов. После трёх неудач — откатитесь к последнему рабочему коммиту.

> **Петля Дори (Dory loop)**. Ситуация, когда ИИ-ассистент бесконечно повторяет фиксы бага, не решая проблему (по аналогии с рыбкой Дори из «В поисках Немо»).

**5. Используй GitHub**. Подключай проект сразу – сразу настрой CI. коммить осмысленные изменения. Это страховка от ошибок ИИ.

> **CI (Continuous Integration)**. Непрерывная интеграция — практика регулярного слияния кода в общий репозиторий с автоматическим запуском тестов.

**6. Для MVP вынеси бизнес-логику в [n8n](https://n8n.io/)**. Пусть фронтенд остаётся простым, а сложные API-вызовы и обработка идут через визуальные воркфлоу.

![n8n – произносится, как «нейтан»](/assets/img/blog/2025/09-16-n8n.webp)

**Когда НЕ стоит** использовать n8n.

- **Очень простая логика** — оставь внутри приложения. Например, если нужно просто проверить правильность email или сложить два числа — проще оставить это в коде (JS/TS, Python и т. д.), чем дергать внешний сервис.
- **Критически важные и быстрые операции**. Если логика должна выполняться мгновенно (например, расчёт цен в реальном времени или авторизация пользователей), то вызовы к n8n через вебхуки могут внести лишнюю задержку и стать точкой отказа.
- **Сложная бизнес-логика с высокой нагрузкой**. При тысячах запросов в секунду n8n может стать узким местом. Лучше перенести эту часть в отдельный сервис (микросервис), оптимизированный под нагрузку.
- **Код, требующий строгой безопасности**. Например, работа с секретами, финансовыми транзакциями или персональными данными. В таких случаях лучше использовать проверенные бэкенд-фреймворки и инфраструктуру с audit-логами.

**7. Добавляй авторизацию на раннем этапе**. Даже простая заглушка на входе спасёт от будущего рефакторинга.

**8. Храни ключи в `.env`** Никогда не хардкодь секреты. Делай мини-аудиты безопасности через LLM.
